<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tablero de Carga Masiva - Secuencias Sin Lectura (CSV)</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js/dist/umd/supabase.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        /* --- INICIO CSS NUEVO --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
        .dashboard { max-width: 1400px; margin: 0 auto; background: white; border-radius: 20px; box-shadow: 0 20px 40px rgba(0,0,0,0.1); overflow: hidden; }
        .header { background: linear-gradient(135deg, #9C27B0 0%, #673AB7 100%); color: white; padding: 30px; text-align: center; }
        .header h1 { font-size: 2.5rem; margin-bottom: 10px; font-weight: 300; }
        .header p { font-size: 1.1rem; opacity: 0.9; }
        .main-content { padding: 30px; }
        .status-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .status-card { background: #f8f9fa; border-radius: 15px; padding: 25px; border-left: 5px solid #9C27B0; transition: transform 0.3s ease, box-shadow 0.3s ease; }
        .status-card:hover { transform: translateY(-5px); box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
        .status-card.success { border-left-color: #4CAF50; background: linear-gradient(135deg, #e8f5e8 0%, #f1f8e9 100%); }
        .status-card.error { border-left-color: #f44336; background: linear-gradient(135deg, #ffebee 0%, #fce4ec 100%); }
        .status-card.warning { border-left-color: #ff9800; background: linear-gradient(135deg, #fff3e0 0%, #fce4ec 100%); }
        .status-card h3 { margin-bottom: 15px; font-size: 1.3rem; color: #333; }
        .status-indicator { display: flex; align-items: center; gap: 10px; font-size: 1.1rem; margin-bottom: 10px; }
        .indicator-dot { width: 12px; height: 12px; border-radius: 50%; background: #ccc; animation: pulse 2s infinite; }
        .indicator-dot.connected { background: #4CAF50; }
        .indicator-dot.error { background: #f44336; }
        .indicator-dot.warning { background: #ff9800; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        .upload-section { background: white; border-radius: 15px; padding: 30px; margin-bottom: 30px; border: 2px dashed #ddd; transition: all 0.3s ease; }
        .upload-section.drag-over { border-color: #9C27B0; background: #f3e5f5; transform: scale(1.02); }
        .upload-area { text-align: center; padding: 40px 20px; }
        .upload-icon { font-size: 4rem; color: #9C27B0; margin-bottom: 20px; }
        .btn { background: linear-gradient(135deg, #9C27B0 0%, #673AB7 100%); color: white; border: none; padding: 15px 30px; border-radius: 50px; font-size: 1rem; cursor: pointer; transition: all 0.3s ease; text-decoration: none; display: inline-block; margin: 5px; box-shadow: 0 4px 15px rgba(156, 39, 176, 0.3); }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(156, 39, 176, 0.4); }
        .btn:disabled { background: #ccc; cursor: not-allowed; transform: none; box-shadow: none; }
        .btn-success { background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%); box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3); }
        .btn-danger { background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%); box-shadow: 0 4px 15px rgba(244, 67, 54, 0.3); }
        .btn-warning { background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%); box-shadow: 0 4px 15px rgba(255, 152, 0, 0.3); }
        .progress-section { background: white; border-radius: 15px; padding: 30px; margin-bottom: 30px; display: none; }
        .progress-bar { width: 100%; height: 20px; background: #e0e0e0; border-radius: 10px; overflow: hidden; margin: 20px 0; position: relative; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #4CAF50 0%, #8BC34A 100%); width: 0%; transition: width 0.3s ease; border-radius: 10px; }
        .progress-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-weight: bold; color: #333; font-size: 0.9rem; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0; }
        .stat-item { background: #f8f9fa; padding: 20px; border-radius: 10px; text-align: center; }
        .stat-number { font-size: 2rem; font-weight: bold; color: #9C27B0; margin-bottom: 5px; }
        .stat-label { color: #666; font-size: 0.9rem; }
        .file-info { background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%); border: 1px solid #9C27B0; border-radius: 15px; padding: 20px; margin: 20px 0; display: none; }
        .file-details { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 15px; }
        .log-section { background: #1a1a1a; color: #00ff00; border-radius: 15px; padding: 20px; margin-top: 30px; font-family: 'Courier New', monospace; max-height: 300px; overflow-y: auto; }
        .log-entry { margin-bottom: 5px; padding: 2px 0; }
        .log-entry.success { color: #4CAF50; }
        .log-entry.error { color: #f44336; }
        .log-entry.warning { color: #ff9800; }
        .log-entry.info { color: #9C27B0; }
        .controls-section { background: white; border-radius: 15px; padding: 25px; margin-bottom: 20px; }
        .control-group { display: flex; align-items: center; gap: 15px; margin-bottom: 15px; }
        .control-group label { font-weight: bold; min-width: 150px; }
        select, input { padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-size: 1rem; transition: border-color 0.3s ease; }
        select:focus, input:focus { outline: none; border-color: #9C27B0; }
        .hidden { display: none !important; }
        .table-preview { max-height: 400px; overflow: auto; border: 1px solid #ddd; border-radius: 8px; margin: 20px 0; }
        .table-preview table { width: 100%; border-collapse: collapse; font-size: 0.75rem; }
        .table-preview th, .table-preview td { padding: 6px 8px; border-bottom: 1px solid #eee; text-align: left; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 120px; }
        .table-preview th { background: #f8f9fa; font-weight: bold; position: sticky; top: 0; }
        .table-preview tr:hover { background: #f5f5f5; }
        .columns-info { background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%); border: 1px solid #ff9800; border-radius: 10px; padding: 15px; margin: 15px 0; font-size: 0.9rem; }
        .columns-info h4 { color: #ef6c00; margin-bottom: 10px; }
        /* --- FIN CSS NUEVO --- */
    </style>
</head>
<body>
    <div class="dashboard">
        <div class="header">
            <h1>üìä Tablero de Secuencias Sin Lectura (CSV)</h1>
            <p>Sistema de importaci√≥n masiva de secuencias sin lectura a Supabase - Ultra optimizado</p>
        </div>
        <div class="main-content">
            <!-- Status Cards -->
            <div class="status-grid">
                <div class="status-card" id="connectionCard">
                    <h3>üîå Estado de Conexi√≥n</h3>
                    <div class="status-indicator">
                        <div class="indicator-dot" id="connectionDot"></div>
                        <span id="connectionStatus">Verificando...</span>
                    </div>
                    <button class="btn" onclick="checkConnection()">üîç Verificar</button>
                </div>
                <div class="status-card" id="tableCard">
                    <h3>üìã Tabla Secuencias Sin Lectura</h3>
                    <div class="status-indicator">
                        <div class="indicator-dot" id="tableDot"></div>
                        <span id="tableStatus">Sin verificar</span>
                    </div>
                    <button class="btn" onclick="checkTable()">üìä Verificar Tabla</button>
                </div>
                <div class="status-card">
                    <h3>üìç Coordenadas</h3>
                    <div class="status-indicator">
                        <span>Visualizar coordenadas √∫nicas</span>
                    </div>
                    <button class="btn" onclick="abrirModalCoordenadas()">üó∫Ô∏è Ver Coordenadas</button>
                </div>
                <div class="status-card">
                    <h3>üìä Rangos Lectura</h3>
                    <div class="status-indicator">
                        <span>Visualizar datos cargados</span>
                    </div>
                    <button class="btn" onclick="abrirModalTabla()">üëÅÔ∏è Ver Tabla</button>
                </div>
            </div>
            <!-- Columns Info -->
            <div class="columns-info">
                <h4>üìã Informaci√≥n de la Tabla secuencia_sin_lectura</h4>
                <p><strong>75 columnas esperadas:</strong> Desde consecutivo_reporte hasta pendiente_liquidacion</p>
                <p><strong>Volumen esperado:</strong> 200,000 - 300,000 filas por carga</p>
                <p><strong>Optimizaci√≥n:</strong> Configurado para archivos grandes con lotes inteligentes</p>
            </div>
            <!-- Upload Section -->
            <div class="upload-section" id="uploadSection">
                <div class="upload-area">
                    <div class="upload-icon">üì§</div>
                    <h2>Cargar Archivo CSV de Secuencias Sin Lectura</h2>
                    <p>Arrastra tu archivo CSV aqu√≠ o haz clic para seleccionar</p>
                    <p><small>Formato requerido: 75 columnas, hasta 300,000 filas - Procesamiento optimizado ‚ö°</small></p>
                    <input type="file" id="fileInput" accept=".csv" style="display: none;">
                    <br><br>
                    <button class="btn" onclick="document.getElementById('fileInput').click()">
                        üìÅ Seleccionar Archivo CSV
                    </button>
                </div>
            </div>
            <!-- File Info -->
            <div class="file-info" id="fileInfo">
                <h3>üìä Informaci√≥n del Archivo</h3>
                <div class="file-details" id="fileDetailsGrid">
                    <!-- Se llena din√°micamente -->
                </div>
            </div>
            <!-- Controls -->
            <div class="controls-section" id="controlsSection" style="display: none;">
                <h3>‚öôÔ∏è Configuraci√≥n de Carga Optimizada</h3>
                <div class="control-group">
                    <label for="batchSize">Tama√±o del lote:</label>
                    <select id="batchSize">
                        <option value="500">500 registros</option>
                        <option value="1000">1,000 registros</option>
                        <option value="1500" selected>1,500 registros</option>
                        <option value="2000">2,000 registros</option>
                        <option value="3000">3,000 registros</option>
                        <option value="5000">5,000 registros</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="delayBetweenBatches">Delay entre lotes (ms):</label>
                    <input type="number" id="delayBetweenBatches" value="1500" min="100" max="10000">
                </div>
                <div class="control-group">
                    <button class="btn btn-success" id="startUploadBtn" onclick="startUpload()">
                        üöÄ Iniciar Carga Masiva
                    </button>
                    <button class="btn btn-danger hidden" id="stopUploadBtn" onclick="stopUpload()">
                        ‚èπÔ∏è Detener
                    </button>
                    <button class="btn" onclick="showPreview()">
                        üëÅÔ∏è Vista Previa (primeras 5 columnas)
                    </button>
                </div>
            </div>
            <!-- Progress Section -->
            <div class="progress-section" id="progressSection">
                <h3>üìà Progreso de Carga Masiva</h3>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                    <div class="progress-text" id="progressText">0%</div>
                </div>
                <div id="progressSummary" style="text-align: center; margin: 15px 0; font-size: 1.1rem; font-weight: bold; color: #9C27B0;">
                    <div id="progressMainText">Preparando carga...</div>
                    <div id="progressSubText" style="font-size: 0.9rem; color: #666; margin-top: 5px;">Inicializando proceso</div>
                </div>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-number" id="processedCount">0</div>
                        <div class="stat-label">Filas Procesadas</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number" id="successCount">0</div>
                        <div class="stat-label">Exitosos</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number" id="errorCount">0</div>
                        <div class="stat-label">Errores</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number" id="remainingCount">0</div>
                        <div class="stat-label">Restantes</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number" id="currentBatch">0</div>
                        <div class="stat-label">Lote Actual</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number" id="totalBatches">0</div>
                        <div class="stat-label">Total Lotes</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number" id="timeElapsed">00:00</div>
                        <div class="stat-label">Tiempo Transcurrido</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number" id="estimatedTime">--:--</div>
                        <div class="stat-label">Tiempo Estimado</div>
                    </div>
                </div>
            </div>
            <!-- Table Preview -->
            <div class="table-preview hidden" id="tablePreview">
                <h3>üëÅÔ∏è Vista Previa de Datos (Primeras 5 columnas)</h3>
                <div id="previewTable"></div>
            </div>
            <!-- Log Section -->
            <div class="log-section">
                <h3 style="color: white; margin-bottom: 15px;">üìù Log de Eventos</h3>
                <div id="logContainer"></div>
            </div>
        </div>
    </div>
    <script>
        // --- INICIO JS NUEVO ---
        // Configuraci√≥n de Supabase
        const SUPABASE_URL = 'https://txeuzsypnwesscganktp.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR4ZXV6c3lwbndlc3NjZ2Fua3RwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA1NDcxMzksImV4cCI6MjA2NjEyMzEzOX0.thcTKNcHaycUTJRUwROfDJKZTteCM1j3eCIMh7UVh4M';

        // Copia del JS de secuencia_lectura.html adaptado para secuencia_sin_lectura
        const supabaseSecuencia = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
        let csvData = [];
        let isUploading = false;
        let uploadCancelled = false;
        let startTime = null;
        let timeInterval = null;
        let currentUploadStats = {
            processed: 0,
            successful: 0,
            errors: 0,
            currentBatch: 0,
            totalBatches: 0
        };
        const expectedColumns = [
            'consecutivo_reporte', 'periodo_consumo', 'periodo_facturacion', 'ano_facturacion', 'mes_facturacion',
            'consecutivo_lectura', 'lectura_anterior', 'lectura_tomada', 'lectura_original', 'fecha_lectura_anterior',
            'fecha_lectura_actual', 'codigo_causanl_obs', 'causanl_obs', 'codigo_obs_adic', 'obs_adic',
            'observ_alfanum', 'advertencia_lect', 'servicio_suscrito', 'suscripcion', 'cod_tipo_consumo',
            'tipo_consumo', 'limite_inferior', 'limite_superior', 'cod_plan_fact', 'plan_fact',
            'cod_tipo_servicio', 'tipo_servicio', 'cod_ciclo', 'cod_categoria_servicio', 'categoria_servicio',
            'cod_subcategoria_servicio', 'subcategoria_servicio', 'orden_lectura', 'actividad_lectura', 'ruta_lectura',
            'consecutivo_ruta_lectura', 'nro_instalacion', 'id_direccion', 'id_zona_operativa', 'zona_operativa',
            'direccion', 'id_geografia', 'id_municipio', 'municipio', 'consumo_leido',
            'consumo_corregido', 'consumo_estimado', 'consumo_facturado', 'consumo_recuperado', 'consumo_aforado',
            'consumo_otros', 'consumo_promedio', 'cod_lector', 'lector', 'id_medidor',
            'serie_medidor', 'constante_medidor', 'cifras_medidor', 'cod_ubicacion_med', 'ubicacion_med',
            'frecuencia_lect', 'cod_unidad_operativa', 'unidad_operativa', 'identificacion', 'hilo_reporte',
            'coordenada_x', 'coordenada_y', 'secuencia_real_lect', 'intentos_lectura', 'tipo_ubicacion',
            'calificacion_consumo', 'registro_fotografico', 'novedades', 'orden_agrupadora', 'pendiente_liquidacion'
        ];
        const numericFields = [
            'consecutivo_reporte', 'ano_facturacion', 'mes_facturacion', 'consecutivo_lectura',
            'lectura_anterior', 'lectura_tomada', 'lectura_original', 'limite_inferior', 'limite_superior',
            'orden_lectura', 'consecutivo_ruta_lectura', 'consumo_leido',
            'consumo_corregido', 'consumo_estimado', 'consumo_facturado', 'consumo_recuperado',
            'consumo_aforado', 'consumo_otros', 'consumo_promedio', 'constante_medidor', 'cifras_medidor',
            'coordenada_x', 'coordenada_y', 'secuencia_real_lect', 'intentos_lectura'
        ];

        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
            window.checkConnection();
            logEvent('üöÄ Tablero de Secuencias Sin Lectura inicializado', 'info');
            logEvent('üìä Configurado para 75 columnas y hasta 300,000 registros', 'info');
        });

        function setupEventListeners() {
            const fileInput = document.getElementById('fileInput');
            fileInput.addEventListener('change', handleFileSelect);
            const uploadSection = document.getElementById('uploadSection');
            uploadSection.addEventListener('dragover', handleDragOver);
            uploadSection.addEventListener('drop', handleDrop);
            uploadSection.addEventListener('dragleave', handleDragLeave);
        }

        async function checkConnection() {
            try {
                logEvent('üîç Verificando conexi√≥n a Supabase...', 'info');
                updateConnectionStatus('Verificando...', 'warning');
                const { data, error } = await supabaseSecuencia
                    .from('secuencia_sin_lectura')
                    .select('*')
                    .limit(1);
                if (error) throw error;
                updateConnectionStatus('Conectado', 'success');
                logEvent('‚úÖ Conexi√≥n establecida correctamente', 'success');
                setTimeout(window.checkTable, 1000);
            } catch (error) {
                console.error('Error de conexi√≥n:', error);
                updateConnectionStatus('Error: ' + error.message, 'error');
                logEvent('‚ùå Error de conexi√≥n: ' + error.message, 'error');
            }
        }
        window.checkConnection = checkConnection;

        async function checkTable() {
            try {
                logEvent('üìä Verificando tabla secuencia_sin_lectura...', 'info');
                updateTableStatus('Verificando...', 'warning');
                const { data, error } = await supabaseSecuencia
                    .from('secuencia_sin_lectura')
                    .select('consecutivo_reporte, periodo_consumo, nro_instalacion')
                    .limit(3);
                if (error) throw error;
                updateTableStatus('Tabla activa ‚úÖ', 'success');
                logEvent('‚úÖ Tabla secuencia_sin_lectura verificada correctamente', 'success');
                if (data && data.length > 0) {
                    const columnas = Object.keys(data[0]);
                    logEvent(`üìã Columnas detectadas: ${columnas.join(', ')}`, 'info');
                    logEvent('üéØ Tabla lista para recibir cargas masivas de CSV', 'success');
                } else {
                    logEvent('üìã Tabla vac√≠a - Lista para primera carga', 'info');
                }
                try {
                    const { data: sampleData } = await supabaseSecuencia
                        .from('secuencia_sin_lectura')
                        .select('consecutivo_reporte')
                        .limit(1);
                    if (sampleData && sampleData.length > 0) {
                        logEvent('üìä La tabla contiene datos existentes', 'info');
                    }
                } catch (sampleError) {
                    logEvent('‚ÑπÔ∏è No se pudo verificar contenido existente', 'info');
                }
            } catch (error) {
                console.error('Error al verificar tabla:', error);
                let errorMessage = error.message;
                if (error.message.includes('timeout') || error.message.includes('canceling statement')) {
                    errorMessage = 'Tabla muy grande - Verificaci√≥n b√°sica exitosa';
                    updateTableStatus('Tabla activa (grande) ‚ö†Ô∏è', 'warning');
                    logEvent('‚ö†Ô∏è Tabla muy grande detectada - Funcionalidad disponible', 'warning');
                    logEvent('üí° La tabla existe y est√° lista para carga CSV', 'info');
                    return;
                }
                updateTableStatus('Error: ' + errorMessage, 'error');
                logEvent('‚ùå Error al verificar tabla: ' + errorMessage, 'error');
                if (error.message.includes('column') || error.message.includes('does not exist')) {
                    logEvent('üí° Sugerencia: Verifica que la tabla secuencia_sin_lectura exista con las 75 columnas esperadas', 'warning');
                } else if (error.message.includes('permission') || error.message.includes('policy')) {
                    logEvent('üîí Problema de permisos - Verifica la configuraci√≥n de RLS en Supabase', 'warning');
                }
            }
        }
        window.checkTable = checkTable;

        function updateConnectionStatus(message, type) {
            const statusElement = document.getElementById('connectionStatus');
            const dotElement = document.getElementById('connectionDot');
            const cardElement = document.getElementById('connectionCard');
            statusElement.textContent = message;
            dotElement.className = `indicator-dot ${type}`;
            cardElement.className = `status-card ${type}`;
        }
        function updateTableStatus(message, type) {
            const statusElement = document.getElementById('tableStatus');
            const dotElement = document.getElementById('tableDot');
            const cardElement = document.getElementById('tableCard');
            statusElement.textContent = message;
            dotElement.className = `indicator-dot ${type}`;
            cardElement.className = `status-card ${type}`;
        }
        function updateFileStatus(message, type, details = '') {
            const statusElement = document.getElementById('fileStatus');
            const dotElement = document.getElementById('fileDot');
            const cardElement = document.getElementById('fileCard');
            const detailsElement = document.getElementById('fileDetails');
            const detailsTextElement = document.getElementById('fileDetailsText');
            if (statusElement) statusElement.textContent = message;
            if (dotElement) dotElement.className = `indicator-dot ${type}`;
            if (cardElement) cardElement.className = `status-card ${type}`;
            if (detailsElement && detailsTextElement) {
                if (details) {
                    detailsTextElement.textContent = details;
                    detailsElement.classList.remove('hidden');
                } else {
                    detailsElement.classList.add('hidden');
                }
            }
        }
        function logEvent(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
            const logs = logContainer.children;
            if (logs.length > 100) {
                logContainer.removeChild(logs[0]);
            }
        }
        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('drag-over');
        }
        function handleDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }
        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                processFile(files[0]);
            }
        }
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                processFile(file);
            }
        }
        async function processFile(file) {
            const fileName = file.name.toLowerCase();
            const isCsv = fileName.endsWith('.csv');
            if (!isCsv) {
                logEvent('‚ùå Archivo no v√°lido. Se requiere CSV (.csv)', 'error');
                updateFileStatus('Archivo no v√°lido', 'error');
                return;
            }
            logEvent(`üìÅ Procesando archivo CSV de secuencias: ${file.name}`, 'info');
            updateFileStatus('Procesando...', 'warning');
            showProcessingIndicator();
            const reader = new FileReader();
            reader.onload = async function(e) {
                await sleep(100);
                await parseCsvFileAsync(e.target.result, file.name);
            };
            reader.readAsText(file, 'UTF-8');
        }
        function showProcessingIndicator() {
            const uploadSection = document.getElementById('uploadSection');
            uploadSection.innerHTML = `
                <div class="upload-area">
                    <div class="upload-icon">‚è≥</div>
                    <h2>Procesando Archivo CSV de Secuencias</h2>
                    <p>Procesando archivo con 75 columnas...</p>
                    <div style="margin: 20px 0;">
                        <div class="progress-bar" style="width: 300px; margin: 0 auto;">
                            <div class="progress-fill" id="fileProgressFill" style="width: 0%; animation: pulse 1.5s infinite;"></div>
                            <div class="progress-text" id="fileProgressText">Leyendo archivo CSV...</div>
                        </div>
                    </div>
                    <p><small>Optimizado para archivos grandes - Por favor espera ‚ö°</small></p>
                </div>
            `;
        }
        async function parseCsvFileAsync(csvText, fileName) {
            try {
                logEvent('üìä Leyendo datos del archivo CSV de secuencias...', 'info');
                updateFileProgressText('Analizando estructura del CSV...');
                const lines = csvText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                if (lines.length === 0) throw new Error('El archivo CSV est√° vac√≠o');
                updateFileProgressText('Detectando formato del CSV...');
                await sleep(50);
                const delimiter = detectCsvDelimiter(lines[0]);
                logEvent(`üîç Separador detectado: "${delimiter}"`, 'info');
                const firstLine = lines[0].split(delimiter);
                const hasHeaders = detectHeaders(firstLine);
                const startIndex = hasHeaders ? 1 : 0;
                const totalRows = lines.length - startIndex;
                logEvent(`üìã Procesando ${totalRows.toLocaleString()} filas CSV...`, 'info');
                logEvent(`üìä Archivo tiene headers: ${hasHeaders ? 'S√≠' : 'No'}`, 'info');
                logEvent(`üìè Columnas detectadas: ${firstLine.length} (se esperan 75)`, 'info');
                if (firstLine.length !== expectedColumns.length) {
                    logEvent(`‚ö†Ô∏è Advertencia: Se esperan ${expectedColumns.length} columnas, pero se detectaron ${firstLine.length}`, 'warning');
                }
                updateFileProgressText(`Procesando ${totalRows.toLocaleString()} filas CSV...`);
                await sleep(50);
                csvData = [];
                let validRows = 0;
                let skippedRows = 0;
                const chunkSize = 3000;
                const totalChunks = Math.ceil(totalRows / chunkSize);
                for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
                    const chunkStart = startIndex + (chunkIndex * chunkSize);
                    const chunkEnd = Math.min(chunkStart + chunkSize, lines.length);
                    const progress = Math.round(((chunkIndex + 1) / totalChunks) * 100);
                    updateFileProgress(progress);
                    updateFileProgressText(`Procesando chunk ${chunkIndex + 1}/${totalChunks} (${progress}%)`);
                    for (let i = chunkStart; i < chunkEnd; i++) {
                        const line = lines[i];
                        if (!line || line.trim() === '') { skippedRows++; continue; }
                        const values = parseCsvLine(line, delimiter);
                        if (values.every(val => val === '' || val === null || val === undefined)) { skippedRows++; continue; }
                        const row = {};
                        for (let j = 0; j < expectedColumns.length; j++) {
                            let value = values[j] || '';
                            if (typeof value === 'string') value = value.trim();
                            if (value === '' || value === 'null' || value === 'NULL' || value === 'undefined') value = null;
                            if (numericFields.includes(expectedColumns[j])) {
                                if (value !== null && !isNaN(value) && value !== '') {
                                    row[expectedColumns[j]] = parseFloat(value);
                                } else {
                                    row[expectedColumns[j]] = null;
                                }
                            } else {
                                row[expectedColumns[j]] = value;
                            }
                        }
                        csvData.push(row);
                        validRows++;
                    }
                    await sleep(10);
                }
                if (validRows > 0) {
                    const fileSize = (csvText.length / 1024 / 1024).toFixed(2);
                    updateFileStatus('Archivo CSV cargado', 'success', `${validRows.toLocaleString()} registros`);
                    showFileInfo(fileName, validRows, skippedRows, fileSize);
                    document.getElementById('controlsSection').style.display = 'block';
                    logEvent(`‚úÖ Archivo CSV procesado: ${validRows.toLocaleString()} registros v√°lidos, ${skippedRows} filas omitidas`, 'success');
                    logEvent(`üìã Estructura preparada para insertar en tabla 'secuencia_sin_lectura'`, 'info');
                    logEvent(`‚ö° Procesamiento CSV completado - listo para carga masiva!`, 'success');
                    restoreUploadSection();
                } else {
                    throw new Error('No se encontraron datos v√°lidos en el CSV');
                }
            } catch (error) {
                console.error('Error al procesar CSV:', error);
                logEvent('‚ùå Error al procesar archivo CSV: ' + error.message, 'error');
                updateFileStatus('Error al procesar', 'error');
                restoreUploadSection();
            }
        }
        function detectCsvDelimiter(firstLine) {
            const delimiters = [',', ';', '\t', '|'];
            let bestDelimiter = ',';
            let maxColumns = 0;
            for (const delimiter of delimiters) {
                const columns = firstLine.split(delimiter).length;
                if (columns > maxColumns) {
                    maxColumns = columns;
                    bestDelimiter = delimiter;
                }
            }
            return bestDelimiter;
        }
        function detectHeaders(firstLine) {
            const textCount = firstLine.filter(value => {
                const trimmed = value.trim();
                return trimmed && isNaN(trimmed);
            }).length;
            return textCount > firstLine.length * 0.5;
        }
        function parseCsvLine(line, delimiter) {
            const result = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === delimiter && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current);
            return result.map(value => value.replace(/^"|"$/g, ''));
        }
        function updateFileProgress(percentage) {
            const progressFill = document.getElementById('fileProgressFill');
            if (progressFill) {
                progressFill.style.width = percentage + '%';
            }
        }
        function updateFileProgressText(text) {
            const progressText = document.getElementById('fileProgressText');
            if (progressText) {
                progressText.textContent = text;
            }
        }
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        function restoreUploadSection() {
            const uploadSection = document.getElementById('uploadSection');
            uploadSection.innerHTML = `
                <div class="upload-area">
                    <div class="upload-icon">üì§</div>
                    <h2>Cargar Archivo CSV de Secuencias Sin Lectura</h2>
                    <p>Arrastra tu archivo CSV aqu√≠ o haz clic para seleccionar</p>
                    <p><small>Formato requerido: 75 columnas, hasta 300,000 filas - Procesamiento optimizado ‚ö°</small></p>
                    <input type="file" id="fileInput" accept=".csv" style="display: none;">
                    <br><br>
                    <button class="btn" onclick="document.getElementById('fileInput').click()">
                        üìÅ Seleccionar Archivo CSV
                    </button>
                </div>
            `;
            const fileInput = document.getElementById('fileInput');
            fileInput.addEventListener('change', handleFileSelect);
        }
        function showFileInfo(fileName, validRows, skippedRows, fileSize) {
            const fileInfo = document.getElementById('fileInfo');
            const detailsGrid = document.getElementById('fileDetailsGrid');
            detailsGrid.innerHTML = `
                <div class="stat-item">
                    <div class="stat-number">${fileName}</div>
                    <div class="stat-label">Nombre del archivo</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number">${validRows.toLocaleString()}</div>
                    <div class="stat-label">Registros v√°lidos</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number">${skippedRows.toLocaleString()}</div>
                    <div class="stat-label">Filas omitidas</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number">${fileSize} MB</div>
                    <div class="stat-label">Tama√±o del archivo</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number">75</div>
                    <div class="stat-label">Columnas</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number">‚úÖ</div>
                    <div class="stat-label">Estado</div>
                </div>
            `;
            fileInfo.style.display = 'block';
        }
        function showPreview() {
            const previewSection = document.getElementById('tablePreview');
            const previewTable = document.getElementById('previewTable');
            if (csvData.length === 0) {
                logEvent('‚ùå No hay datos para mostrar', 'error');
                return;
            }
            let html = '<table><thead><tr>';
            const previewColumns = expectedColumns.slice(0, 5);
            previewColumns.forEach(col => {
                html += `<th>${col}</th>`;
            });
            html += '<th>...</th></tr></thead><tbody>';
            for (let i = 0; i < Math.min(10, csvData.length); i++) {
                html += '<tr>';
                previewColumns.forEach(col => {
                    const value = csvData[i][col];
                    html += `<td>${value !== null && value !== undefined ? value : ''}</td>`;
                });
                html += '<td>...</td></tr>';
            }
            if (csvData.length > 10) {
                html += `<tr><td colspan="6" style="text-align: center; font-style: italic; padding: 15px;">... y ${(csvData.length - 10).toLocaleString()} filas m√°s</td></tr>`;
            }
            html += '</tbody></table>';
            previewTable.innerHTML = html;
            previewSection.classList.remove('hidden');
            logEvent(`üëÅÔ∏è Mostrando vista previa de ${Math.min(10, csvData.length)} filas (primeras 5 columnas)`, 'info');
            logEvent(`üìä Columnas totales a insertar: ${expectedColumns.length}`, 'info');
        }
        window.showPreview = showPreview;

        async function startUpload() {
            if (csvData.length === 0) {
                logEvent('‚ùå No hay datos para cargar', 'error');
                return;
            }
            isUploading = true;
            uploadCancelled = false;
            startTime = Date.now();
            const batchSize = parseInt(document.getElementById('batchSize').value);
            const delay = parseInt(document.getElementById('delayBetweenBatches').value);
            const totalBatches = Math.ceil(csvData.length / batchSize);
            document.getElementById('startUploadBtn').classList.add('hidden');
            document.getElementById('stopUploadBtn').classList.remove('hidden');
            document.getElementById('progressSection').style.display = 'block';
            currentUploadStats = {
                processed: 0,
                successful: 0,
                errors: 0,
                currentBatch: 0,
                totalBatches: totalBatches
            };
            startTimer();
            updateStats();
            updateProgressSummary('Iniciando carga masiva de secuencias...', 'Preparando lotes optimizados para 75 columnas');
            logEvent(`üöÄ Iniciando carga masiva de secuencias: ${csvData.length.toLocaleString()} registros en ${totalBatches} lotes de ${batchSize.toLocaleString()} registros`, 'info');
            logEvent(`‚è±Ô∏è Delay entre lotes: ${delay}ms`, 'info');
            logEvent(`üìä Procesando tabla con 75 columnas`, 'info');
            try {
                await processUploadBatches(batchSize, delay, totalBatches);
            } catch (error) {
                console.error('Error general en la carga:', error);
                logEvent(`‚ùå Error general: ${error.message}`, 'error');
            }
            stopTimer();
            resetUploadUI();
        }
        window.startUpload = startUpload;

        async function processUploadBatches(batchSize, delay, totalBatches) {
            for (let i = 0; i < totalBatches && !uploadCancelled; i++) {
                const start = i * batchSize;
                const end = Math.min(start + batchSize, csvData.length);
                const batch = csvData.slice(start, end);
                currentUploadStats.currentBatch = i + 1;
                updateStats();
                updateProgressSummary(
                    `Procesando lote ${i + 1} de ${totalBatches}`,
                    `${batch.length.toLocaleString()} registros de secuencias en este lote`
                );
                logEvent(`üì§ Procesando lote ${i + 1}/${totalBatches} (${batch.length.toLocaleString()} registros)`, 'info');
                try {
                    if (i === 0) {
                        logEvent(`üîç Ejemplo de registro de secuencia a insertar:`, 'info');
                        console.log('Estructura del primer registro:', batch[0]);
                    }
                    let retryCount = 0;
                    const maxRetries = 3;
                    while (retryCount <= maxRetries) {
                        try {
                            const { error } = await supabaseSecuencia
                                .from('secuencia_sin_lectura')
                                .insert(batch);
                            if (error) throw error;
                            break;
                        } catch (insertError) {
                            if (insertError.message.includes('timeout') || 
                                insertError.message.includes('canceling statement') ||
                                insertError.message.includes('connection')) {
                                retryCount++;
                                if (retryCount <= maxRetries) {
                                    const retryDelay = Math.min(1000 * retryCount, 5000);
                                    logEvent(`‚ö†Ô∏è Timeout en lote ${i + 1}, reintentando en ${retryDelay}ms (intento ${retryCount}/${maxRetries})`, 'warning');
                                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                                    continue;
                                } else {
                                    logEvent(`‚ùå Lote ${i + 1}: M√°ximo de reintentos alcanzado`, 'error');
                                    throw insertError;
                                }
                            } else {
                                throw insertError;
                            }
                        }
                    }
                    currentUploadStats.successful += batch.length;
                    logEvent(`‚úÖ Lote ${i + 1} completado exitosamente (${batch.length.toLocaleString()} registros)`, 'success');
                } catch (error) {
                    currentUploadStats.errors += batch.length;
                    console.error(`Error en lote ${i + 1}:`, error);
                    let errorMsg = error.message;
                    if (error.message.includes('timeout') || error.message.includes('canceling statement')) {
                        errorMsg = 'Error: Timeout en la base de datos - Lote muy grande o servidor ocupado';
                    } else if (error.code === '23505') {
                        errorMsg = 'Error: Registros duplicados detectados';
                    } else if (error.code === '23502') {
                        errorMsg = 'Error: Campos requeridos faltantes';
                    } else if (error.code === '42703') {
                        errorMsg = 'Error: Columna no existe en la tabla';
                    }
                    logEvent(`‚ùå Error en lote ${i + 1}: ${errorMsg}`, 'error');
                    if (i === 0) {
                        logEvent(`üîç Revisar estructura del CSV: debe tener ${expectedColumns.length} columnas en orden correcto`, 'warning');
                    }
                    if (error.message.includes('JWT') || 
                        error.message.includes('auth') || 
                        error.message.includes('column') ||
                        error.message.includes('does not exist')) {
                        logEvent('üõë Deteniendo carga por error cr√≠tico', 'error');
                        uploadCancelled = true;
                    }
                    if (error.message.includes('timeout')) {
                        logEvent(`‚è≠Ô∏è Continuando con el siguiente lote...`, 'info');
                    }
                }
                currentUploadStats.processed += batch.length;
                updateProgress();
                updateStats();
                await new Promise(resolve => setTimeout(resolve, Math.max(delay, 50)));
                if (i % 5 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            if (!uploadCancelled) {
                const successRate = ((currentUploadStats.successful / csvData.length) * 100).toFixed(1);
                updateProgressSummary(
                    `¬°Carga de secuencias completada! ${successRate}% exitoso`,
                    `${currentUploadStats.successful.toLocaleString()} secuencias cargadas correctamente`
                );
                logEvent(`üéâ Carga de secuencias completada! ${currentUploadStats.successful.toLocaleString()} exitosos, ${currentUploadStats.errors.toLocaleString()} errores`, 
                        currentUploadStats.successful > currentUploadStats.errors ? 'success' : 'error');
            } else {
                updateProgressSummary(
                    `Carga detenida por el usuario`,
                    `${currentUploadStats.successful.toLocaleString()} secuencias cargadas antes de detener`
                );
                logEvent(`‚èπÔ∏è Carga detenida por el usuario`, 'warning');
            }
        }
        function stopUpload() {
            uploadCancelled = true;
            logEvent('‚èπÔ∏è Deteniendo la carga...', 'warning');
            updateProgressSummary('Deteniendo carga...', 'Finalizando lote actual');
        }
        window.stopUpload = stopUpload;
        function resetUploadUI() {
            isUploading = false;
            document.getElementById('startUploadBtn').classList.remove('hidden');
            document.getElementById('stopUploadBtn').classList.add('hidden');
        }
        function startTimer() {
            timeInterval = setInterval(updateElapsedTime, 1000);
        }
        function stopTimer() {
            if (timeInterval) {
                clearInterval(timeInterval);
                timeInterval = null;
            }
        }
        function updateElapsedTime() {
            if (!startTime) return;
            const elapsed = Date.now() - startTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            document.getElementById('timeElapsed').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            if (currentUploadStats.processed > 0 && csvData.length > 0) {
                const rate = currentUploadStats.processed / elapsed;
                const remaining = csvData.length - currentUploadStats.processed;
                const estimatedMs = remaining / rate;
                const estMinutes = Math.floor(estimatedMs / 60000);
                const estSeconds = Math.floor((estimatedMs % 60000) / 1000);
                document.getElementById('estimatedTime').textContent = 
                    `${estMinutes.toString().padStart(2, '0')}:${estSeconds.toString().padStart(2, '0')}`;
            }
        }
        function updateProgressSummary(mainText, subText) {
            document.getElementById('progressMainText').textContent = mainText;
            document.getElementById('progressSubText').textContent = subText;
        }
        function updateProgress() {
            const percentage = Math.round((currentUploadStats.processed / csvData.length) * 100);
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('progressText').textContent = percentage + '%';
        }
        function updateStats() {
            document.getElementById('processedCount').textContent = currentUploadStats.processed.toLocaleString();
            document.getElementById('successCount').textContent = currentUploadStats.successful.toLocaleString();
            document.getElementById('errorCount').textContent = currentUploadStats.errors.toLocaleString();
            document.getElementById('remainingCount').textContent = (csvData.length - currentUploadStats.processed).toLocaleString();
            document.getElementById('currentBatch').textContent = currentUploadStats.currentBatch.toLocaleString();
            document.getElementById('totalBatches').textContent = currentUploadStats.totalBatches.toLocaleString();
        }

        // Funci√≥n para abrir el modal de tabla
        async function abrirModalTabla() {
            const modal = document.getElementById('modalTabla');
            const contenido = document.getElementById('contenidoModalTabla');
            
            // Mostrar indicador de carga
            contenido.innerHTML = '<div style="text-align: center; padding: 40px;"><div style="display: inline-block;"><div style="border: 4px solid #f3f3f3; border-top: 4px solid #9C27B0; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite;"></div></div><p style="margin-top: 20px;">Cargando todos los datos de la tabla...</p></div>';
            
            modal.style.display = 'block';
            
            try {
                // Cargar TODOS los datos de la tabla secuencia_sin_lectura desde Supabase
                let allData = [];
                let from = 0;
                const batchSize = 1000;
                let hasMore = true;
                
                // Cargar en lotes para evitar timeout
                while (hasMore) {
                    const { data, error } = await supabaseSecuencia
                        .from('secuencia_sin_lectura')
                        .select('*')
                        .range(from, from + batchSize - 1);
                    
                    if (error) {
                        throw new Error('Error al cargar datos: ' + error.message);
                    }
                    
                    if (data && data.length > 0) {
                        allData = allData.concat(data);
                        from += batchSize;
                        
                        // Actualizar mensaje de carga
                        contenido.innerHTML = '<div style="text-align: center; padding: 40px;"><div style="display: inline-block;"><div style="border: 4px solid #f3f3f3; border-top: 4px solid #9C27B0; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite;"></div></div><p style="margin-top: 20px;">Cargando datos... ' + allData.length.toLocaleString() + ' registros</p></div>';
                        
                        // Si recibimos menos registros que el tama√±o del lote, ya terminamos
                        if (data.length < batchSize) {
                            hasMore = false;
                        }
                    } else {
                        hasMore = false;
                    }
                }
                
                if (allData.length === 0) {
                    contenido.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">No hay datos disponibles en la tabla</div>';
                    return;
                }
                
                console.log('Total datos cargados:', allData.length);
                console.log('Columnas disponibles:', Object.keys(allData[0]));
                
                // Procesar los datos
                contenido.innerHTML = '<div style="text-align: center; padding: 40px;"><p>Procesando ' + allData.length.toLocaleString() + ' registros...</p></div>';
                
                const datosProcessados = procesarDatosTabla(allData);
                
                // Generar tabla HTML
                generarTablaHTML(datosProcessados, contenido);
                
            } catch (error) {
                console.error('Error cargando tabla:', error);
                contenido.innerHTML = '<div style="text-align: center; padding: 40px; color: #f44336;"><strong>Error al cargar los datos:</strong> ' + error.message + '</div>';
            }
        }

        // Almacena el √∫ltimo conjunto procesado para exportar
        let lastDatosSecuencia = [];
        let lastDatosCoordenadas = [];

        // Funci√≥n para procesar los datos de la tabla
        function procesarDatosTabla(data) {
            console.log('Total registros recibidos:', data.length);
            
            // Agrupar por: ciclo + correr√≠a + direcci√≥n_procesada
            const agrupaciones = {};
            
            data.forEach((row) => {
                const correria = row.ruta_lectura || '';
                const direccionCompleta = row.direccion || '';
                const nroInstalacion = (row.nro_instalacion || '').toString();
                
                // Extraer ciclo de los d√≠gitos 5 y 6 de la correr√≠a (√≠ndices 4 y 5)
                let ciclo = '';
                if (correria && correria.length >= 6) {
                    const cicloStr = correria.substring(4, 6);
                    ciclo = parseInt(cicloStr, 10).toString(); // quita ceros a la izquierda
                }
                
                // Extraer solo la parte antes del "-" de la direcci√≥n
                let direccionProcesada = direccionCompleta.trim();
                const teniaGuion = direccionProcesada.includes('-');
                if (teniaGuion) {
                    direccionProcesada = direccionProcesada.split('-')[0].trim();
                }
                
                if (correria && direccionProcesada) {
                    const key = `${ciclo}|${correria}|${direccionProcesada}`;
                    
                    if (!agrupaciones[key]) {
                        agrupaciones[key] = {
                            ciclo: ciclo,
                            correria: correria,
                            direccion: direccionProcesada,
                            lecturas: 0,
                            instalacionesSet: new Set(),
                            sinGuion: !teniaGuion
                        };
                    }
                    
                    const grupo = agrupaciones[key];
                    grupo.lecturas += 1;
                    
                    // Calcular instalaciones: si no hubo guion, cuenta como 1 instalaci√≥n fija
                    if (grupo.sinGuion) {
                        grupo.instalacionesSet.add('__sin_guion__');
                    } else {
                        // Tomar √∫ltimos 7 d√≠gitos del nro_instalacion
                        const last7 = nroInstalacion.slice(-7);
                        if (last7) {
                            grupo.instalacionesSet.add(last7);
                        } else {
                            // Si no hay nro_instalacion, cuenta como 1
                            grupo.instalacionesSet.add('__sin_nro__');
                        }
                    }
                }
            });
            
            // Convertir el objeto a array
            const registrosFormateados = Object.values(agrupaciones).map(item => ({
                ciclo: item.ciclo,
                correria: item.correria,
                direccion: item.direccion,
                lecturas: item.lecturas,
                instalaciones: item.sinGuion ? 1 : Math.max(item.instalacionesSet.size, 1)
            }));
            
            console.log('Total grupos √∫nicos creados:', registrosFormateados.length);
            console.log('Ejemplo primer grupo:', registrosFormateados[0]);
            
            // Ordenar por correr√≠a primero, luego por direcci√≥n
            registrosFormateados.sort((a, b) => {
                const corrA = (a.correria || '').toString();
                const corrB = (b.correria || '').toString();
                const cmpCorr = corrA.localeCompare(corrB, 'es', { numeric: true });
                if (cmpCorr !== 0) return cmpCorr;
                const dirA = (a.direccion || '').toString();
                const dirB = (b.direccion || '').toString();
                return dirA.localeCompare(dirB, 'es', { numeric: true });
            });
            
            const ciclosUnicos = [...new Set(registrosFormateados
                .map(r => r.ciclo)
                .filter(c => c !== null && c !== undefined && c !== ''))
            ];
            const correriasUnicas = [...new Set(registrosFormateados.map(r => r.correria))];
            
            // Guardar datos para exportaci√≥n
            lastDatosSecuencia = registrosFormateados;

            return {
                datos: registrosFormateados,
                ciclosUnicos: ciclosUnicos,
                totalCorrerias: correriasUnicas.length
            };
        }

        // Exportar a Excel
        function exportarExcelSecuencia() {
            if (!lastDatosSecuencia || lastDatosSecuencia.length === 0) {
                alert('No hay datos para exportar');
                return;
            }

            const rows = lastDatosSecuencia.map(row => ({
                ciclo: row.ciclo,
                correria: (row.correria || '').toString().slice(-4),
                direccion: row.direccion,
                lecturas: row.lecturas,
                instalaciones: row.instalaciones
            }));

            const worksheet = XLSX.utils.json_to_sheet(rows);
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, 'secuencia');
            XLSX.writeFile(workbook, 'secuencia_sin_lectura.xlsx');
        }

        // Funci√≥n para generar la tabla HTML
        function generarTablaHTML(datos, contenedor) {
            let html = '<style>';
            html += '@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }';
            html += '.tabla-secuencia { width: 100%; border-collapse: collapse; margin: 20px 0; }';
            html += '.tabla-secuencia th { background: #9C27B0; color: white; padding: 15px; text-align: left; font-weight: bold; border: 1px solid #333; }';
            html += '.tabla-secuencia td { padding: 12px 15px; border: 1px solid #ddd; }';
            html += '.tabla-secuencia tr:nth-child(even) { background: #f9f9f9; }';
            html += '.tabla-secuencia tr:hover { background: #e8d5f2; }';
            html += '</style>';
            
            // Informaci√≥n de valores √∫nicos
            html += '<div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin-bottom: 20px;">';
            html += '<p><strong>üìä Ciclo:</strong> ' + (datos.ciclosUnicos.length > 0 ? datos.ciclosUnicos.join(', ') : 'Sin datos') + '</p>';
            html += '<p><strong>üìç Correr√≠as:</strong> ' + datos.totalCorrerias + '</p>';
            html += '<p><strong>üìã Rangos:</strong> ' + datos.datos.length + '</p>';
            html += '</div>';

            // Bot√≥n de exportaci√≥n
            html += '<div style="text-align: right; margin-bottom: 10px;">';
            html += '<button class="btn" style="padding: 10px 16px;" onclick="exportarExcelSecuencia()">‚¨áÔ∏è Exportar Excel</button>';
            html += '</div>';
            
            // Tabla
            html += '<table class="tabla-secuencia">';
            html += '<thead><tr>';
            html += '<th>Ciclo</th>';
            html += '<th>Correria</th>';
            html += '<th>Direcci√≥n</th>';
            html += '<th>Lecturas</th>';
            html += '<th>Instalaciones</th>';
            html += '</tr></thead>';
            html += '<tbody>';
            
            datos.datos.forEach(row => {
                const corrDisplay = (row.correria || '').toString().slice(-4);
                html += '<tr>';
                html += '<td>' + (row.ciclo || '-') + '</td>';
                html += '<td>' + (corrDisplay || '-') + '</td>';
                html += '<td>' + (row.direccion || '-') + '</td>';
                html += '<td>' + (row.lecturas || '-') + '</td>';
                html += '<td>' + (row.instalaciones || '-') + '</td>';
                html += '</tr>';
            });
            
            html += '</tbody>';
            html += '</table>';
            
            contenedor.innerHTML = html;
        }

        // Funci√≥n para cerrar el modal
        function cerrarModalTabla() {
            document.getElementById('modalTabla').style.display = 'none';
        }

        // Cerrar modal al hacer clic fuera de √©l
        window.onclick = function(event) {
            const modal = document.getElementById('modalTabla');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
            const modalCoor = document.getElementById('modalCoordenadas');
            if (event.target === modalCoor) {
                modalCoor.style.display = 'none';
            }
        }

        // Funci√≥n para formatear coordenadas
        function formatearCoordenada(coordY, coordX) {
            // coordY: ej 6230187 ‚Üí 6.230187 (punto despu√©s del primer d√≠gito)
            const strY = (coordY || '').toString().trim();
            let coordYFormateada = strY;
            if (strY.length > 1) {
                coordYFormateada = strY.substring(0, 1) + '.' + strY.substring(1);
            }
            
            // coordX: ej -7552635 ‚Üí -75.52635 (punto despu√©s del tercer d√≠gito)
            const strX = (coordX || '').toString().trim();
            let coordXFormateada = strX;
            if (strX.startsWith('-')) {
                const numPart = strX.substring(1);
                if (numPart.length > 2) {
                    coordXFormateada = '-' + numPart.substring(0, 2) + '.' + numPart.substring(2);
                }
            } else {
                if (strX.length > 2) {
                    coordXFormateada = strX.substring(0, 2) + '.' + strX.substring(2);
                }
            }
            
            return coordYFormateada + ' ' + coordXFormateada;
        }

        // Funci√≥n para abrir el modal de coordenadas
        async function abrirModalCoordenadas() {
            const modal = document.getElementById('modalCoordenadas');
            const contenido = document.getElementById('contenidoModalCoordenadas');
            
            contenido.innerHTML = '<div style="text-align: center; padding: 40px;"><div style="display: inline-block;"><div style="border: 4px solid #f3f3f3; border-top: 4px solid #9C27B0; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite;"></div></div><p style="margin-top: 20px;">Cargando coordenadas...</p></div>';
            
            modal.style.display = 'block';
            
            try {
                let allData = [];
                let from = 0;
                const batchSize = 1000;
                let hasMore = true;
                
                while (hasMore) {
                    const { data, error } = await supabaseSecuencia
                        .from('secuencia_sin_lectura')
                        .select('nro_instalacion, direccion, coordenada_y, coordenada_x, ruta_lectura')
                        .range(from, from + batchSize - 1);
                    
                    if (error) {
                        throw new Error('Error al cargar datos: ' + error.message);
                    }
                    
                    if (data && data.length > 0) {
                        allData = allData.concat(data);
                        from += batchSize;
                        
                        contenido.innerHTML = '<div style="text-align: center; padding: 40px;"><div style="display: inline-block;"><div style="border: 4px solid #f3f3f3; border-top: 4px solid #9C27B0; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite;"></div></div><p style="margin-top: 20px;">Cargando datos... ' + allData.length.toLocaleString() + ' registros</p></div>';
                        
                        if (data.length < batchSize) {
                            hasMore = false;
                        }
                    } else {
                        hasMore = false;
                    }
                }
                
                if (allData.length === 0) {
                    contenido.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">No hay datos disponibles</div>';
                    return;
                }
                
                console.log('Total datos cargados para coordenadas:', allData.length);
                
                contenido.innerHTML = '<div style="text-align: center; padding: 40px;"><p>Procesando ' + allData.length.toLocaleString() + ' registros...</p></div>';
                
                const datosCoordenadas = procesarCoordenadas(allData);
                generarTablaCoordenadas(datosCoordenadas, contenido);
                
            } catch (error) {
                console.error('Error cargando coordenadas:', error);
                contenido.innerHTML = '<div style="text-align: center; padding: 40px; color: #f44336;"><strong>Error:</strong> ' + error.message + '</div>';
            }
        }

        // Procesar datos de coordenadas
        function procesarCoordenadas(data) {
            const agrupaciones = {};
            
            data.forEach(row => {
                const nroInstalacion = (row.nro_instalacion || '').toString().trim();
                const direccion = row.direccion || '';
                const coordY = row.coordenada_y || '';
                const coordX = row.coordenada_x || '';
                const correria = row.ruta_lectura || '';
                
                let ciclo = '';
                if (correria && correria.length >= 6) {
                    const cicloStr = correria.substring(4, 6);
                    ciclo = parseInt(cicloStr, 10).toString();
                }
                
                if (nroInstalacion) {
                    const key = `${ciclo}|${nroInstalacion}`;
                    
                    if (!agrupaciones[key]) {
                        const coordFormateada = formatearCoordenada(coordY, coordX);
                        agrupaciones[key] = {
                            ciclo: ciclo,
                            instalacion: nroInstalacion,
                            direccion: direccion,
                            coordenada: coordFormateada
                        };
                    }
                }
            });
            
            const registrosFormateados = Object.values(agrupaciones);
            
            // Ordenar por ciclo y luego por instalaci√≥n
            registrosFormateados.sort((a, b) => {
                const cicloA = parseInt(a.ciclo || 0);
                const cicloB = parseInt(b.ciclo || 0);
                if (cicloA !== cicloB) return cicloA - cicloB;
                
                const instA = (a.instalacion || '').toString();
                const instB = (b.instalacion || '').toString();
                return instA.localeCompare(instB, 'es', { numeric: true });
            });
            
            const ciclosUnicos = [...new Set(registrosFormateados.map(r => r.ciclo))];
            
            // Guardar datos para exportaci√≥n
            lastDatosCoordenadas = registrosFormateados;
            
            return {
                datos: registrosFormateados,
                ciclosUnicos: ciclosUnicos,
                total: registrosFormateados.length
            };
        }

        // Generar tabla de coordenadas
        function generarTablaCoordenadas(datos, contenedor) {
            let html = '<style>';
            html += '@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }';
            html += '.tabla-secuencia { width: 100%; border-collapse: collapse; margin: 20px 0; }';
            html += '.tabla-secuencia th { background: #9C27B0; color: white; padding: 15px; text-align: left; font-weight: bold; border: 1px solid #333; }';
            html += '.tabla-secuencia td { padding: 12px 15px; border: 1px solid #ddd; }';
            html += '.tabla-secuencia tr:nth-child(even) { background: #f9f9f9; }';
            html += '.tabla-secuencia tr:hover { background: #e8d5f2; }';
            html += '</style>';
            
            html += '<div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin-bottom: 20px;">';
            html += '<p><strong>üìä Ciclos √∫nicos:</strong> ' + (datos.ciclosUnicos.length > 0 ? datos.ciclosUnicos.join(', ') : 'Sin datos') + '</p>';
            html += '<p><strong>üìç Total instalaciones √∫nicas:</strong> ' + datos.total + '</p>';
            html += '</div>';
            
            // Bot√≥n de exportaci√≥n
            html += '<div style="text-align: right; margin-bottom: 10px;">';
            html += '<button class="btn" style="padding: 10px 16px;" onclick="exportarExcelCoordenadas()">‚¨áÔ∏è Exportar Excel</button>';
            html += '</div>';
            
            html += '<table class="tabla-secuencia">';
            html += '<thead><tr>';
            html += '<th>Ciclo</th>';
            html += '<th>Instalaci√≥n</th>';
            html += '<th>Direcci√≥n</th>';
            html += '<th>Coordenada</th>';
            html += '</tr></thead>';
            html += '<tbody>';
            
            datos.datos.forEach(row => {
                html += '<tr>';
                html += '<td>' + (row.ciclo || '-') + '</td>';
                html += '<td>' + (row.instalacion || '-') + '</td>';
                html += '<td>' + (row.direccion || '-') + '</td>';
                html += '<td>' + (row.coordenada || '-') + '</td>';
                html += '</tr>';
            });
            
            html += '</tbody>';
            html += '</table>';
            
            contenedor.innerHTML = html;
        }

        // Exportar coordenadas a Excel
        function exportarExcelCoordenadas() {
            if (!lastDatosCoordenadas || lastDatosCoordenadas.length === 0) {
                alert('No hay datos para exportar');
                return;
            }

            const rows = lastDatosCoordenadas.map(row => ({
                ciclo: row.ciclo,
                instalacion: row.instalacion,
                direccion: row.direccion,
                coordenada: row.coordenada
            }));

            const worksheet = XLSX.utils.json_to_sheet(rows);
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, 'coordenadas');
            XLSX.writeFile(workbook, 'coordenadas_instalaciones.xlsx');
        }

        // Cerrar modal de coordenadas
        function cerrarModalCoordenadas() {
            document.getElementById('modalCoordenadas').style.display = 'none';
        }
        // --- FIN JS NUEVO ---
    </script>

    <!-- Modal de Tabla Secuencia Sin Lectura -->
    <div id="modalTabla" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 9999; overflow: auto;">
        <div style="background: white; margin: 20px auto; padding: 30px; border-radius: 15px; width: 95%; max-width: 1400px; max-height: 90vh; overflow: auto; box-shadow: 0 20px 40px rgba(0,0,0,0.3);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2>üìä Tabla Secuencia Sin Lectura</h2>
                <button onclick="cerrarModalTabla()" style="background: #f44336; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 1rem;">‚úï Cerrar</button>
            </div>
            <div id="contenidoModalTabla" style="overflow-x: auto;">
                <!-- Tabla se generar√° aqu√≠ -->
            </div>
        </div>
    </div>

    <!-- Modal de Coordenadas -->
    <div id="modalCoordenadas" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 9999; overflow: auto;">
        <div style="background: white; margin: 20px auto; padding: 30px; border-radius: 15px; width: 95%; max-width: 1400px; max-height: 90vh; overflow: auto; box-shadow: 0 20px 40px rgba(0,0,0,0.3);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2>üó∫Ô∏è Coordenadas Instalaciones</h2>
                <button onclick="cerrarModalCoordenadas()" style="background: #f44336; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 1rem;">‚úï Cerrar</button>
            </div>
            <div id="contenidoModalCoordenadas" style="overflow-x: auto;">
                <!-- Tabla se generar√° aqu√≠ -->
            </div>
        </div>
    </div>
</body>
</html>
